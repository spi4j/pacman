[module RsFrontResources('http://www.eclipse.org/ocl/1.1.0/Ecore')/]

[import fr::pacman::commons::common::licence/]
[import fr::pacman::commons::common::packages/]
[import fr::pacman::commons::common::classes/]
[import fr::pacman::commons::common::names/]
[import fr::pacman::commons::common::properties/]
[import fr::pacman::commons::common::imports/]
[import fr::pacman::commons::convention::rule::methodRule/]
[import fr::pacman::commons::convention::rule::parameterRule/]
[import fr::pacman::commons::convention::rule::attributeRule/]
[import fr::pacman::commons::convention::rule::variableRule/]
[import fr::pacman::commons::convention::rule::classRule/]
[import fr::pacman::commons::convention::rule::commonRule/]

[comment encoding = UTF-8 /]
[comment : **********************************************************/]
[comment : Create the client factory for the import front resources. /]
[comment : **********************************************************/]
[template public rsDefaultClientFactory(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import java.security.KeyManagementException;
    import java.security.NoSuchAlgorithmException;
    import java.security.SecureRandom;
    import java.security.cert.X509Certificate;
    
    import javax.net.ssl.HostnameVerifier;
    import javax.net.ssl.KeyManager;
    import javax.net.ssl.SSLContext;
    import javax.net.ssl.SSLSession;
    import javax.net.ssl.TrustManager;
    import javax.net.ssl.X509TrustManager;
    import jakarta.ws.rs.client.Client;
    import jakarta.ws.rs.client.ClientBuilder;
    import jakarta.ws.rs.core.Response.Status;
    
    import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
    import org.glassfish.jersey.apache.connector.ApacheClientProperties;
    import org.glassfish.jersey.apache.connector.ApacheConnectorProvider;
    import org.glassfish.jersey.client.ClientConfig;
    import org.glassfish.jersey.client.ClientProperties;
    import org.glassfish.jersey.jackson.internal.jackson.jaxrs.json.JacksonJaxbJsonProvider;
    import org.glassfish.jersey.jackson.internal.jackson.jaxrs.json.JacksonJsonProvider;
    import org.glassfish.jersey.media.multipart.MultiPartFeature;
    
    import com.fasterxml.jackson.databind.DeserializationFeature;
    
    import [any.buildPackageRsFrontExceptions()/].[any.buildRSFrontExceptionClassName()/];
    
  [/protected]
  
  
  /**
   * Fabrique pour le pool de connexion des clients http (Jersey).
   *
   * @author [any.getAuthorName()/].
   */
  public final class [any.buildRSClientFactoryClassName()/]
  {
  	/**
  	* Le pool de connexions clients REST Jersey.
  	*/
  	private static Client ['http client pool'.apply_attributeStatic()/];
  
  	/**
  	 * Création d'un pool de connexions pour le client HTTP Jersey.
  	 *
  	 * @return le pool de connexions.
  	 */
  	public static Client ['client'.apply_methodGet()/]() {
  
  		// Si le pool est déja créé on le retourne directement.
  		if (null != ['http client pool'.apply_attributeStatic()/]) {
  			return ['http client pool'.apply_attributeStatic()/];
  		}
  
  		// L'implémentation par défaut du connecteur Jersey utilise la classe
  		// HttpURLConnection du JDK. Cette classe restreint l'utilisation de
  		// quelques en-têtes. Pour éviter cette restriction, mise en place de
  		// cette propriété système.
  
  		System.setProperty("sun.net.http.allowRestrictedHeaders", "true");
  
  		// Configuration par défaut très permissive dans le cadre du débogage pour
  		// la déséralisation Json. Modifier selon convenance pour la mise en production.
  
      	JacksonJsonProvider ['jackson json provider'.apply_variableDefault()/] = new JacksonJaxbJsonProvider()
  			.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, Boolean.FALSE)
  			.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, Boolean.FALSE)
  			.configure(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS, Boolean.FALSE)
  			.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, Boolean.TRUE)
  			.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, Boolean.TRUE)
  			.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, Boolean.TRUE);
  
  		// Initialisation du pool de connexions pour le client.
  		PoolingHttpClientConnectionManager ['connection manager'.apply_variableDefault()/] = new PoolingHttpClientConnectionManager();
  		['connection manager'.apply_variableDefault()/].setMaxTotal([any.buildRSFrontConfigClassName()/].['max pool clients'.apply_methodGet()/]());
  
  		// Le client Jersey 2.1 est "thread-safe" et devrait toujours l'être dans les futures
  		// versions de Jersey. Il est possible de créer plusieurs WebTarget à partir d'une
  		// seule instance du client, et ainsi d'appeller plusieurs requêtes sur la "WebTarget".
  
  		// Pour enregistrer des composants supplémentaires, faites-le sur le client déjà créé
  		// (et non la cible) afin d'empêcher une autre création du "runtime" client.
  
  		// Pour le fonctionnement d'un service derrière HTTPS, il est nécessaire de créer
  		// un client qui prenne en charge une connexion chiffrée. La configuration par
  		// défaut est minimale et permet de passer l'ensemble des fournisseurs de ressources.
  		// A Modifier pour une solution plus sécurisée en production.
  
  		// Configuration du client.
  		ClientConfig ['client config'.apply_variableDefault()/] = new ClientConfig();
  		ApacheConnectorProvider ['connector'.apply_variableDefault()/] = new ApacheConnectorProvider();
  
  		['client config'.apply_variableDefault()/].property(ClientProperties.READ_TIMEOUT, 
  			[any.buildRSFrontConfigClassName()/].['read timeout'.apply_methodGet()/]());
  
  		['client config'.apply_variableDefault()/].property(ClientProperties.CONNECT_TIMEOUT, 
  			[any.buildRSFrontConfigClassName()/].['connect timeout'.apply_methodGet()/]());
  
  		['client config'.apply_variableDefault()/].property(ApacheClientProperties.CONNECTION_MANAGER, 
  			['connection manager'.apply_variableDefault()/]);
  
  		['client config'.apply_variableDefault()/].register([any.buildRSFrontResourcesDefaultFilter()/].class);
  		['client config'.apply_variableDefault()/].register([any.buildRSFrontResourcesDefaultInterceptor()/].class);
  		['client config'.apply_variableDefault()/].register(MultiPartFeature.class);
  		['client config'.apply_variableDefault()/].register(['jackson json provider'.apply_variableDefault()/]);
  		['client config'.apply_variableDefault()/].connectorProvider(['connector'.apply_variableDefault()/]);
  
  		// Configuration du proxy si necessaire.
  		if(null != [any.buildRSFrontConfigClassName()/].['proxy url'.apply_methodGet()/]()
  			&& ! [any.buildRSFrontConfigClassName()/].['proxy url'.apply_methodGet()/]().isEmpty()) {
  
  			['client config'.apply_variableDefault()/].property(ClientProperties.PROXY_URI, 
  					[any.buildRSFrontConfigClassName()/].['proxy url'.apply_methodGet()/]());
  			['client config'.apply_variableDefault()/].property(ClientProperties.PROXY_USERNAME,
  					[any.buildRSFrontConfigClassName()/].['proxy user'.apply_methodGet()/]());
  			['client config'.apply_variableDefault()/].property(ClientProperties.PROXY_PASSWORD,
  					[any.buildRSFrontConfigClassName()/].['proxy passwd'.apply_methodGet()/]());
  		}
  
  		// Initialisation du Builder.
  		ClientBuilder ['client builder'.apply_variableDefault()/] = ClientBuilder.newBuilder();
  	
  		// Si demande de sécurisation pour SSL.
  		if([any.buildRSFrontConfigClassName()/].['is socket secured'.apply_methodDefault()/]()) {
  			['client builder'.apply_variableDefault()/].sslContext([' SSL context'.apply_methodGet()/]())
  			.hostnameVerifier(new [any.buildInternalHostnameVerifier()/]());
  		}
  
  		// Création du client à partir du "Builder".
  		['http client pool'.apply_attributeStatic()/] = ['client builder'.apply_variableDefault()/].withConfig(['client config'.apply_variableDefault()/]).build();
  
  		// retourne le pool nouvellement créé.
  		return ['http client pool'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Récupération du contexte SSL.
  	*
  	* @return Le contexte SSL.
  	* @throws NoSuchAlgorithmException
  	* @throws KeyManagementException
  	*/
  	public static SSLContext [' SSL context'.apply_methodGet()/]() {
  
  		['SSL context'.apply_methodGet().displayClearUserCodeId()/]
  		[protected (any.getUserCodeId('SSL context'.apply_methodGet())) startTagPrefix('//') endTagPrefix('//')]
      
      		SSLContext ['ssl context'.apply_variableDefault()/] = null;
      
      		try {
      
      			// A modifier selon les versions TLSv1 / TLSv1.2...
      			['ssl context'.apply_variableDefault()/] = SSLContext.getInstance("TLSv1.2");
      
      			final KeyManager['['/]] ['key manager'.apply_variableFinal()/] = null;
      			final TrustManager['['/]] ['trust manager'.apply_variableFinal()/] = { new [any.buildInternalTrustManager()/]() };
      			final SecureRandom ['secure random'.apply_variableFinal()/] = new SecureRandom();
      
      			['ssl context'.apply_variableDefault()/].init(['key manager'.apply_variableFinal()/],
      				['trust manager'.apply_variableFinal()/], ['secure random'.apply_variableFinal()/]);
      
      		} catch (NoSuchAlgorithmException e) {
      
      			throw new [any.buildRSFrontExceptionClassName()/](
      				Status.INTERNAL_SERVER_ERROR.getStatusCode(),
      				"Impossible de charger le gestionnaire de sécurité.");
      
      		} catch (KeyManagementException e) {
      
      			throw new [any.buildRSFrontExceptionClassName()/](
      				Status.INTERNAL_SERVER_ERROR.getStatusCode(),
      				"Impossible de charger le gestionnaire de sécurité.");
      		}
      		return ['ssl context'.apply_variableDefault()/];
      
    [/protected]
  
  	}
  
  	/**
  	* Vérification des certificats.
  	*/
  	private static class [any.buildInternalTrustManager()/] implements X509TrustManager {
  
  		[any.buildInternalTrustManager().displayClearUserCodeId()/]
  		[protected (any.getUserCodeId(any.buildInternalTrustManager())) startTagPrefix('//') endTagPrefix('//')]
      
      		@Override
      		public void checkClientTrusted(X509Certificate['['/]] ['x509 certificates'.apply_parameterMethodClassicIn()/],
      			String ['s'.apply_parameterMethodClassicIn()/]) {
      		}
      
      		@Override
      		public void checkServerTrusted(X509Certificate['['/]]  ['x509 certificates'.apply_parameterMethodClassicIn()/],
      			String ['s'.apply_parameterMethodClassicIn()/]) {
      		}
      
      		@Override
      		public X509Certificate['['/]] getAcceptedIssuers() {
      			return new X509Certificate['['/]0];
      		}
      
    [/protected]
  
  	}
  
  	/**
  	* Vérification des noms d'hôte.
  	*/
  	private static class [any.buildInternalHostnameVerifier()/] implements HostnameVerifier {
  
  		[any.buildInternalHostnameVerifier().displayClearUserCodeId()/]
  		[protected (any.getUserCodeId(any.buildInternalHostnameVerifier())) startTagPrefix('//') endTagPrefix('//')]
      
      		@Override
      		public boolean verify(String ['s'.apply_parameterMethodClassicIn()/], SSLSession ['ssl session'.apply_parameterMethodClassicIn()/]) {
      			return Boolean.TRUE;
      		}
      
    [/protected]
  
  	}
  }[/template]

[comment : ***********************************************************/]
[comment : Create a standard class exception for the front resources. /]
[comment : ***********************************************************/]
[template public rsFrontStandardException(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFrontExceptions()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import [any.buildPackageRsFront()/].[any.buildRSFrontConfigClassName()/];
    import jakarta.ws.rs.client.ClientResponseContext;
    import jakarta.ws.rs.core.Response.Status;
    import jakarta.ws.rs.ProcessingException;
    import java.net.URI;
    
  [/protected]
  
  
  /**
   * Exception générique pour l'application : [any.getApplicationName()/].
   * <p>
   * Dans le cas ou cette classe est utilisée avec un frontal jsp et/ou avec des
   * services web de type Rest, il est fortement conseillé d'importer la librairie
   * Spi4j et d'ajouter une implémentation de type "implements RsFrontException"
   * afin de pouvoir bénéficier d'une remontée d'information plus importante au
   * niveau des exceptions.
   *
   * @author [any.getAuthorName()/].
   */
  
  [any.buildRSFrontExceptionClassName().displayClearUserCodeId()/]
  [protected (any.getUserCodeId(any.buildRSFrontExceptionClassName())) startTagPrefix('// ') endTagPrefix('// ')]
    
    public class [any.buildRSFrontExceptionClassName()/] extends RuntimeException {
    
  [/protected]
  
  
  	/**
  	* L'ID de série par défaut.
  	*/
  	private static final long serialVersionUID = -3077568312514165073L;
  
  	/**
  	* Le code de retour d'état HTTP pour l'opération.
  	*/
  	private final int ['status code'.apply_attributeFinal()/];
  
  	/**
  	* Informations supplémentaires pour l'erreur (si existe).
  	*/
  	private String ['additional info'.apply_attributeDefault()/];
  
  	/**
  	* L'URI appelée ayant généré l'exception.
  	*/
  	private URI ['called Uri'.apply_attributeDefault()/];
  
  	/**
  	* Constructeur.
  	*
  	* @param ['exception'.apply_parameterMethodClassicIn()/] :
  	* 			L'exception initiale.
  	*/
  	public [any.buildRSFrontExceptionClassName()/](final Exception ['exception'.apply_parameterMethodClassicIn()/]){
  
  		super(['exception'.apply_parameterMethodClassicIn()/]);
  		['status code'.apply_attributeFinal()/] = Status.INTERNAL_SERVER_ERROR.getStatusCode();
  	}
  
  	/**
  	* Constructeur.
  	*
  	* @param ['statut code'.apply_parameterMethodClassicIn()/] :
  	* 			Le code de retour d'état HTTP pour l'opération.
  	*/
  	public [any.buildRSFrontExceptionClassName()/](final int ['statut code'.apply_parameterMethodClassicIn()/]){
  
  		[any.getAffectationPrefix()/]['status code'.apply_attributeFinal()/] = ['statut code'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Constructeur.
  	*
  	* @param ['statut code'.apply_parameterMethodClassicIn()/] :
  	* 			Le code de retour d'état HTTP pour l'opération.
  	* @param ['reason'.apply_parameterMethodClassicIn()/] :
  	* 			The message associated to the HTTP return code.
  	*/
  	public [any.buildRSFrontExceptionClassName()/](final int ['statut code'.apply_parameterMethodClassicIn()/], final String ['reason'.apply_parameterMethodClassicIn()/]){
  
  		super(['reason'.apply_parameterMethodClassicIn()/]);
  		[any.getAffectationPrefix()/]['status code'.apply_attributeFinal()/] = ['statut code'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Constructeur.
  	*
  	* @param ['response context'.apply_parameterMethodClassicIn()/] :
  	* 			Le contexte de la réponse.
  	*/
  	public [any.buildRSFrontExceptionClassName()/](final ClientResponseContext ['response context'.apply_parameterMethodClassicIn()/]){
  
  		super(['response context'.apply_parameterMethodClassicIn()/].getStatusInfo().getReasonPhrase());
  		['status code'.apply_attributeFinal()/] = ['response context'.apply_parameterMethodClassicIn()/].getStatus();
  	}
  
  	/**
  	* Récupération de l'exception encapsulée dans la "processingException" de Jersey afin que l'API 
  	* puisse toujours renvoyer une [any.buildRSFrontExceptionClassName()/].
  	*
  	* @param ['exception'.apply_parameterMethodClassicIn()/] :
  	* 			L'exception à traiter.
  	*/
  	public static [any.buildRSFrontExceptionClassName()/] ['cast'.apply_methodDefault()/](final ProcessingException ['exception'.apply_parameterMethodClassicIn()/]) {
  		
  		if(['exception'.apply_parameterMethodClassicIn()/].getCause() instanceof [any.buildRSFrontExceptionClassName()/]) {
  			return ([any.buildRSFrontExceptionClassName()/])['exception'.apply_parameterMethodClassicIn()/].getCause();
  		}
  		return new [any.buildRSFrontExceptionClassName()/](['exception'.apply_parameterMethodClassicIn()/]);
  	}
  
  	/**
  	* Récupération du code de retour HTTP
  	*
  	* @return Le code d'état.
  	*/
  	public int ['status code'.apply_methodGet()/]() {
  
  		return ['status code'.apply_attributeFinal()/];
  	}
  
  	/**
  	* Récupération de l'URI ayant généré l'exception.
  	*
  	* @return L'URI.
  	*/
  	public URI ['called uri'.apply_methodGet()/]() {
  	
  		return ['called uri'.apply_attributeDefault()/];
  	}
  
  	/**
  	* Mise à jour de l'URI ayant généré l'exception.
  	*
  	* @param ['called uri'.apply_attributeDefault()/] : 
  	* 					L'URI ayant généré l'exception.
  	*/
  	public void ['called uri'.apply_methodSet()/](URI ['called uri'.apply_parameterMethodClassicIn()/]) {
  	
  		// Uniquement si mode debug !
  		if (![any.buildRSFrontConfigClassName()/].['is debug mode'.apply_methodDefault()/]()) {
  				return;
  		}
  
  		[any.getAffectationPrefix()/]['called uri'.apply_attributeDefault()/] = ['called uri'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération des éventuelles informations supplémentaires pour l'erreur.
  	* 
  	* @return Les informations supplémentaires.
  	*/
  	public String ['additional info'.apply_methodGet()/]() {
  
  		return ['additional info'.apply_attributeDefault()/];
  	}
  
  	/**
  	* Mise à jour des informations supplémentaires pour l'erreur.
  	* 
  	* @param ['additional info'.apply_parameterMethodClassicIn()/] : 
      * 					La ou les informations supplémentaires.
  	*/
  	public void ['additional info'.apply_methodSet()/](final String ['additional info'.apply_parameterMethodClassicIn()/]) {
  	
  		[any.getAffectationPrefix()/]['additional info'.apply_attributeDefault()/] = ['additional info'.apply_parameterMethodClassicIn()/];
  	}
  }[/template]

[comment : ********************************************************************/]
[comment : Create a default interceptor for the jersey client (front resource). /]
[comment : ********************************************************************/]
[template public rsFrontResourceDefaultInterceptor(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import java.io.IOException;
    
    import jakarta.ws.rs.WebApplicationException;
    import jakarta.ws.rs.ext.ReaderInterceptor;
    import jakarta.ws.rs.ext.ReaderInterceptorContext;
    import jakarta.ws.rs.ext.WriterInterceptor;
    import jakarta.ws.rs.ext.WriterInterceptorContext;
    
  [/protected]
  
  /**
   * Intercepteur vide par défaut pour l'application : [any.getApplicationName()/].
   *
   * Les intercepteurs sont principalement utilisés pour modifier les flux d'entrée et 
   * de sortie des entités. Il est possible d'utiliser des intercepteurs, par exemple, pour 
   * compresser et décompresser les flux d'entités de sortie et d'entrée.
   * 
   * Garder à l'esprit qu'un intercepteur est toujours exécuté après les filtres et 
   * uniquement si un corps de message est présent.
   *
   * @author [any.getAuthorName()/].
   */
  public class [any.buildRSFrontResourcesDefaultInterceptor()/] implements WriterInterceptor, ReaderInterceptor  {
  
  	@Override
  	public Object aroundReadFrom(ReaderInterceptorContext ['context'.apply_parameterMethodClassicIn()/]) 
  			throws IOException, WebApplicationException {
  		
  		[protected (any.getUserCodeId(any.buildRSFrontResourcesDefaultInterceptor() + '_aroundReadFrom')) startTagPrefix('//') endTagPrefix('//')]
      		
      		return ['context'.apply_parameterMethodClassicIn()/].proceed();
      
    [/protected]
   
  	}
  
  	@Override
  	public void aroundWriteTo(WriterInterceptorContext ['context'.apply_parameterMethodClassicIn()/]) 
  			throws IOException, WebApplicationException {
  
  		[protected (any.getUserCodeId(any.buildRSFrontResourcesDefaultInterceptor() + '_aroundWriteTo')) startTagPrefix('//') endTagPrefix('//')]
      		
      		['context'.apply_parameterMethodClassicIn()/].proceed();
      			
    [/protected]
   
  	}
  }[/template]

[comment : ****************************************************************/]
[comment : Create a default filter for the jersey client (front resource). /]
[comment : ****************************************************************/]
[template public rsFrontResourceDefaultFilter(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import java.io.ByteArrayInputStream;
    import java.io.InputStream;
    import java.io.IOException;
    import java.util.Locale;
    
    import org.apache.commons.io.IOUtils;
    
    import jakarta.ws.rs.client.ClientRequestContext;
    import jakarta.ws.rs.client.ClientRequestFilter;
    import jakarta.ws.rs.client.ClientResponseContext;
    import jakarta.ws.rs.client.ClientResponseFilter;
    import jakarta.ws.rs.core.Response.Status.Family;
    import jakarta.ws.rs.core.HttpHeaders;
    
    import org.glassfish.jersey.client.ClientResponse;
    
    import [any.buildPackageRsFrontExceptions()/].[any.buildRSFrontExceptionClassName()/];
    
  [/protected]
  
  
  /**
   * Filtre par défaut pour l'application.
   * Placer ici l'ensemble du code pour gérer les exceptions, modifier les en-têtes
   * en fonction des différents routages possibles etc..
   *
   * @author [any.getAuthorName()/].
   */
  public class [any.buildRSFrontResourcesDefaultFilter()/] implements ClientRequestFilter, ClientResponseFilter  {
  
  	/**
  	* Stockage du jeton spécifique pour une passerelle API. 
  	* (Hors jeton applicatif).
  	*/
  	private static String ['auth gateway token'.apply_attributeStatic()/];
  
  	/**
  	* Enregistre le jeton spécifique pour la passerelle API (si derrière passerelle).
  	* En l'état actuel du PES, ce jeton est UNIQUE pour l'ensemble de l'application.
  	* Ici l'assesseur sert simplement de "passe-plat" et est synchronisé lors 
  	* du changement de jeton uniquement si ce dernier est périmé.
  	*
  	* @param ['gateway token'.apply_parameterMethodClassicIn()/] : 
  	*				Le jeton pour la passerelle d'API.
  	*/
  	public static synchronized void ['register auth gateway token'.apply_methodDefault()/](final String ['auth gateway token'.apply_parameterMethodClassicIn()/]){
  		
  		[any.buildRSFrontResourcesDefaultFilter()/].['auth gateway token'.apply_attributeStatic()/] = ['auth gateway token'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Avant appel du client.
  	*
  	* @param ['request context'.apply_parameterMethodClassicIn()/] :
  	*			L'objet de contexte pour la requête.
  	*/
  	@Override
  	public void filter(ClientRequestContext ['request context'.apply_parameterMethodClassicIn()/]) throws IOException {
  
  		[any.getUserCodeId(any.buildRSFrontResourcesDefaultFilter() + '_ClientRequestContext').displayClearUserCodeId()/]
  		[protected (any.getUserCodeId(any.buildRSFrontResourcesDefaultFilter() + '_ClientRequestContext')) startTagPrefix('// ') endTagPrefix('// ')]
      
      		// Indique que le client converse en Français (si possible).
      		['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(HttpHeaders.ACCEPT_LANGUAGE, Locale.FRENCH);
      
      		// Ajout des en-têtes pour la Passerelle PES (si besoin).
      		['add PES headers'.apply_methodDefault()/](['request context'.apply_parameterMethodClassicIn()/]);
      
      		// Si mode débug, on stocke les en-têtes dans le ThreadLocal.
      		[any.buildRSFrontResourcesContextHolder()/].['headers'.apply_methodSet()/](['request context'.apply_parameterMethodClassicIn()/].getHeaders());
      
    [/protected]
  
  	}
  
  	/**
  	* Après appel du client et avant traitement de la réponse.
  	* 
  	* La réponse implémente AutoCloseable depuis 1.7 donc pas besoin de fermer 
  	* si une exception technique est levée pendant la désérialisation. Ici ne 
  	* sont traitées que des exceptions fonctionnelles, il ne devrait donc pas 
  	* y pas y avoir besoin de finally pour la fermeture des ressources (s'il y 
    	* a tout de même une entité dans le corps du message). 
  	*
  	* @param ['request context'.apply_parameterMethodClassicIn()/] :
  	*			L'objet de contexte pour la requête.
  	* @param ['response context'.apply_parameterMethodClassicIn()/] :
  	* 			L'objet de contexte pour la réponse.
  	*/
  	@Override
  	public void filter(ClientRequestContext ['request context'.apply_parameterMethodClassicIn()/],
  		ClientResponseContext ['response context'.apply_parameterMethodClassicIn()/]) throws IOException {
  
  		[any.getUserCodeId(any.buildRSFrontResourcesDefaultFilter() + '_ClientResponseFilter').displayClearUserCodeId()/]
  		[protected (any.getUserCodeId(any.buildRSFrontResourcesDefaultFilter() + '_ClientResponseFilter')) startTagPrefix('// ') endTagPrefix('// ')]
      
      		// Si mode débug, on stocke les en-têtes dans le ThreadLocal.
      		[any.buildRSFrontResourcesContextHolder()/].['update with headers'.apply_methodDefault()/](['response context'.apply_parameterMethodClassicIn()/].getHeaders());
      
      		// Vérification du statut pour la réponse.
      		if(['response context'.apply_parameterMethodClassicIn()/].getStatusInfo().getFamily()!= Family.SUCCESSFUL) {
      
      			// On crée une exception contenant le code de retour du service.
      			final [any.buildRSFrontExceptionClassName()/] ['rs exception'.apply_variableFinal()/] = new [any.buildRSFrontExceptionClassName()/](['response context'.apply_parameterMethodClassicIn()/]);
      
      			// Récupère des informations supplémentaires dans le corps de la réponse (si besoin).
      			['rs exception'.apply_variableFinal()/].['additional info'.apply_methodSet()/](['error entity stream'.apply_methodGet()/](['response context'.apply_parameterMethodClassicIn()/]));
      
      			// On demande expressement la fermeture pour le contexte.
      			((ClientResponse)['response context'.apply_parameterMethodClassicIn()/]).close();
      			
      			// Si mode debug, on rajoute l'URI.
      			['rs exception'.apply_variableFinal()/].['called uri'.apply_methodSet()/](['request context'.apply_parameterMethodClassicIn()/].getUri());
      			
      			// On lance l'exception.
      			throw ['rs exception'.apply_variableFinal()/];
      		}
      
    [/protected]
  
  	}
  
  	/**
  	 * Ajout des en-têtes spécifiques pour la Passerelle PES. 
  	 * Dans le cas ou le jeton d'authentification pour la passerelle est "null",
  	 * on ne fait aucun test, c'est la passerelle qui doit renvoyer l'erreur.
  	 *
  	 * @param ['request context'.apply_parameterMethodClassicIn()/] :
  	 *			L'objet de contexte pour la requête.
  	 */
  	private void ['add PES headers'.apply_methodDefault()/]( final ClientRequestContext ['request context'.apply_parameterMethodClassicIn()/]) {
  
  		if([any.buildRSFrontConfigClassName()/].['is pes headers required'.apply_methodDefault()/]()) {
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header secu key'.apply_methodGet()/](),
  				[any.buildRSFrontConfigClassName()/].['pes header secu'.apply_methodGet()/]());
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header mention key'.apply_methodGet()/](),
  				[any.buildRSFrontConfigClassName()/].['pes header mention'.apply_methodGet()/]());
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header constraint key'.apply_methodGet()/](),
  				[any.buildRSFrontConfigClassName()/].['pes header constraint'.apply_methodGet()/]());
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header app key'.apply_methodGet()/](),
  				[any.buildRSFrontConfigClassName()/].['pes application name'.apply_methodGet()/]());
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header dlpp key'.apply_methodGet()/](),
  				['request context'.apply_parameterMethodClassicIn()/].getUri().getPath());
  			['request context'.apply_parameterMethodClassicIn()/].getHeaders().add(
  				[any.buildRSFrontConfigClassName()/].['pes header token key'.apply_methodGet()/](),
  				['auth gateway token'.apply_attributeStatic()/]);
  		}
  	}
  
  	/**
  	 * Récupération des informations éventuellement présentes dans l'entité si le
  	 * fournisseur d'API a choisi d'envoyer aussi des informations dans le corps du
  	 * message.
  	 * 
  	 * @param ['response context'.apply_parameterMethodClassicIn()/] :
  	 * @throws IOException 
  	 */
  	private String ['error entity stream'.apply_methodGet()/](final ClientResponseContext ['response context'.apply_parameterMethodClassicIn()/]) throws IOException {
  
  		if (['response context'.apply_parameterMethodClassicIn()/].hasEntity()){
  			try ( InputStream ['entity stream'.apply_variableDefault()/] = ['response context'.apply_parameterMethodClassicIn()/].getEntityStream()) {
  				byte['['/]] bytes = IOUtils.toByteArray(['entity stream'.apply_variableDefault()/]);
  				['response context'.apply_parameterMethodClassicIn()/].setEntityStream(new ByteArrayInputStream(bytes));
  				return new String(bytes).replaceAll("['['/]{}]", "");
  
  			} catch (Exception e) {
  				return "Erreur de lecture pour les informations complémentaires !";
  			} 
  		}
  		return "Aucune information complémentaire pour l'erreur.";
  	}
  }[/template]

[comment : ***************************************************************************/]
[comment : Create a Holder for ThreadLocal storage of the request / response context. /]
[comment : ***************************************************************************/]
[template public rsFrontResourceContextHolder(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import jakarta.ws.rs.core.MultivaluedMap;
    
  [/protected]
  
  
  /**
   * Cette classe permet de stocker temporairement (ThreadLocal) les données des en-têtes 
   * à partir du filtre pour les tests JUnit si le développeur désire afficher les en-têtes 
   * pour déboger l'Api.
   *
   * @author [any.getAuthorName()/]
   */
  public class [any.buildRSFrontResourcesContextHolder()/] {
  	
  	/**
  	* ThreadLocal pour le stockage temporaire des en-têtes. 
  	* (dans le cadre du debogage).
  	*/
  	private static ThreadLocal<Headers> ['headers _thread _local'.apply_attributeStatic()/] = new ThreadLocal<Headers>();
  
  	/**
  	 * Initialisation pour le stockage des en-têtes.
  	 *
  	 * @param ['map'.apply_parameterMethodClassicIn()/] : 
  	 * 					La map de stockage des indormations en-tête pour la requête.
  	 */
  	public static void ['headers'.apply_methodSet()/](MultivaluedMap<String, Object> ['map'.apply_parameterMethodClassicIn()/]) {
  
  		// Uniquement si mode debug !
  		if (![any.buildRSFrontConfigClassName()/].['is debug mode'.apply_methodDefault()/]()) {
  				return;
  		}
  
  		[any.getAffectationPrefix()/].['headers _thread _local'.apply_attributeStatic()/]
  				.set(new Headers(['map'.apply_parameterMethodClassicIn()/]));
  	}
  
  	/**
  	 * Mise à jour du ThreadLocal avec les données en-tête de la réponse.
  	 *
  	 * @param ['map'.apply_parameterMethodClassicIn()/] : 
  	 * 					La map de stockage des indormations en-tête pour la réponse.
  	 */
  	public static void ['update with headers'.apply_methodDefault()/](MultivaluedMap<String, String> ['map'.apply_parameterMethodClassicIn()/]) {
  
  		// Uniquement si mode debug !
  		if (![any.buildRSFrontConfigClassName()/].['is debug mode'.apply_methodDefault()/]()) {
  				return;
  		}
  
  		[any.buildRSFrontResourcesContextHolder()/].['headers'.apply_methodGet()/]()
  			.['update with response headers'.apply_methodDefault()/](['map'.apply_parameterMethodClassicIn()/]);
  	}
  
  	/**
  	 * Récupération des ent-têtes (request + response).
  	 *
  	 * @return l'objet contenant les en-têtes.
  	 */
  	public static Headers ['headers'.apply_methodGet()/]() {
  		
  		return [any.getAffectationPrefix()/]['headers _thread _local'.apply_attributeStatic()/].get();
  	}
  
  	/**
  	 * Suppression des en-têtes dans le ThreadLocal.
  	 */
  	public static void ['remove'.apply_methodDefault()/]() {
  		
  		[any.getAffectationPrefix()/]['headers _thread _local'.apply_attributeStatic()/].remove();
  		[any.getAffectationPrefix()/].['headers _thread _local'.apply_attributeStatic()/] = null;
  	}
  	
  	/**
  	 * Conteneur pour les information des en-têtes.
  	 *
  	 * @author [any.getAuthorName()/]
  	 */
  	public static class Headers {
  	
  		/**
  		* Stocke les en-têtes de la requête.
  		*/
  		private MultivaluedMap<String, Object> ['request headers'.apply_attributeDefault()/];
  
  		/**
  		* Stocke les en-têtes de la réponse.
  		*/
  		private MultivaluedMap<String, String> ['response headers'.apply_attributeDefault()/];
  
  		/**
  		 * Constructeur.
  		 * 
  		 * @param ['request headers'.apply_parameterMethodClassicIn()/] : 
  		 *					La liste des en-têtes pour le contexte de la requête.
  		 */
  		public Headers(MultivaluedMap<String, Object> ['request headers'.apply_parameterMethodClassicIn()/]) {
  
  			[any.getAffectationPrefix()/]['request headers'.apply_attributeDefault()/] = 
  					['request headers'.apply_parameterMethodClassicIn()/];
  		}
  
  		/**
  		 * Mise à jour des informations avec les en-têtes de la réponse.
  		 *
  		 * @param ['response headers'.apply_parameterMethodClassicIn()/] : 
  		 * 					La liste des en-têtes pour le contexte de la réponse.
  		 */
  		public void ['update with response headers'.apply_methodDefault()/](
  				MultivaluedMap<String, String> ['response headers'.apply_parameterMethodClassicIn()/]) {
  
  			[any.getAffectationPrefix()/]['response headers'.apply_attributeDefault()/] = 
  				['response headers'.apply_parameterMethodClassicIn()/];
  		}
  
  		/**
  		 * Récupération des en-têtes dans le contexte de la requête.
  		 *
  		 * @return La liste des en-têtes pour le contexte de la requête.
  		 */
  		public MultivaluedMap<String, Object> ['request headers'.apply_methodGet()/]() {
  			
  			return ['request headers'.apply_attributeDefault()/];
  		}
  
  		/**
  		 * Récupération des ent-têtes dans le contexte de la réponse.
  		 *
  		 * @return La liste des en-têtes pour le contexte de la réponse.
  		 */
  		public MultivaluedMap<String, String> ['response headers'.apply_methodGet()/]() {
  			
  			return ['response headers'.apply_attributeDefault()/];
  		}
  	}
  }[/template]

[comment : ***************************************************************/]
[comment : Create the class for tokens configuration loading and storage. /]
[comment : ***************************************************************/]
[template public rsFrontTokensConfiguration(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import java.util.Properties;
    
  [/protected]
  
  /**
  * Classe détenant les informations des jetons.
  *
  * @author [any.getAuthorName()/].
  */
  public class [any.buildRSFrontTokensConfigClassName()/] {
   	/**
     	* Chargement de la configuration des jetons pour l'application.
     	*
     	* @param ['properties'.apply_parameterMethodClassicIn()/] :
     	* 				Le chargeur pour la configuration des jetons.
     	*/
  	static void loadConfiguration(final Properties ['properties'.apply_parameterMethodClassicIn()/]){
  		
  		//RAS.
  	}
  }[/template]

[comment : ********************************************************/]
[comment : Create the class for configuration loading and storage. /]
[comment : ********************************************************/]
[template public rsFrontConfiguration(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.InputStream;
    import java.util.Properties;
    import java.net.URI;
    
    import jakarta.ws.rs.core.Response.Status;
    
    import org.apache.logging.log4j.LogManager;
    import org.apache.logging.log4j.Logger;
    
    import [any.buildPackageRsFrontExceptions()/].[any.buildRSFrontExceptionClassName()/];
    
  [/protected]
  
  
  /**
   * Classe détenant les informations nécessaires pour la configuration générale
   * de l'application. Comme la configuration doit être chargée au niveau du filtre
   * ET de la classe "Utilitaire" spécifique à chaque ressource ET de la classe Helper 
   * pour les tests JUnit (qui contient des méthodes 'static'), l'ensemble de la configuration 
   * est donc 'static' pour plus de simplicité, il ne s'agit pas d'un singleton, un simple
   * booléen évite le chargement multiple de la configuration (équivaut à instance != null).
   *
   * @author [any.getAuthorName()/]
   */
  public class [any.buildRSFrontConfigClassName()/] {
  
  	/**
  	 * Le logger pour le chargement de la configuration.
  	 */
  	private final static Logger ['config log'.apply_attributeFinalStatic()/] = LogManager.getLogger([any.buildRSFrontConfigClassName()/].class);
  
  	private static final String ['conf _filter _props _file'.apply_attributeFinalStatic()/]  = "_REST_CONFIG_FILES";
    	private static final String ['conf _filter _pes _header _constraint'.apply_attributeFinalStatic()/] = "filter.pes.header.constraint";
    	private static final String ['conf _filter _pes _header _mention'.apply_attributeFinalStatic()/] = "filter.pes.header.mention";
    	private static final String ['conf _filter _pes _header _secu'.apply_attributeFinalStatic()/] = "filter.pes.header.secu";
    	private static final String ['conf _filter _pes _header _app'.apply_attributeFinalStatic()/] = "filter.pes.header.app";
    	private static final String ['conf _filter _routing _strategy'.apply_attributeFinalStatic()/] = "filter.routing.strategy";
    	private static final String ['conf _filter _operating _mode'.apply_attributeFinalStatic()/] = "filter.mode.operating";
    	private static final String ['conf _filter _base _url'.apply_attributeFinalStatic()/] = "filter.server.url"; 
  	private static final String ['conf _filter _proxy _url'.apply_attributeFinalStatic()/] = "filter.proxy.url"; 
  	private static final String ['conf _filter _proxy _user'.apply_attributeFinalStatic()/] = "filter.proxy.user";
  	private static final String ['conf _filter _proxy _passwd'.apply_attributeFinalStatic()/] = "filter.proxy.passwd";
    	private static final String ['conf _filter _socket _secured'.apply_attributeFinalStatic()/] = "filter.socket.secured";
  	private static final String ['conf _client _connect _timeout'.apply_attributeFinalStatic()/] = "client.timeout.connect";
  	private static final String ['conf _client _read _timeout'.apply_attributeFinalStatic()/] = "client.timeout.read";
  	private static final String ['conf _client _pool _max'.apply_attributeFinalStatic()/] = "client.pool.max";
  	private static final String ['conf _debug _display _attr _upper'.apply_attributeFinalStatic()/] = "debug.display.attr.upper";
  	private static final String ['conf _debug _display _headers'.apply_attributeFinalStatic()/] = "debug.display.headers";
  
    	static final String ['auth _header _pes _secu'.apply_attributeFinalStatic()/] = "filter.pes.header.secu.key";
    	static final String ['auth _header _pes _mention'.apply_attributeFinalStatic()/] = "filter.pes.header.mention.key";
    	static final String ['auth _header _pes _constraint'.apply_attributeFinalStatic()/] = "filter.pes.header.constraint.key";
    	static final String ['auth _header _pes _app _name'.apply_attributeFinalStatic()/] = "filter.pes.header.app.key";
    	static final String ['auth _header _pes _dlpp '.apply_attributeFinalStatic()/] = "filter.pes.header.dlpp.key";
  	static final String ['auth _header _pes _token'.apply_attributeFinalStatic()/] = "filter.pes.header.token.key";
  
    	/**
     	* Verifie si la demande de chargement a déjà été effectuée.
     	*/
    	private static boolean ['loaded'.apply_attributeStatic()/];
  
    	/**
     	* Le mode de routage pour les ressources.
     	*/
    	private static ['routing strategy'.apply_classEnum()/] ['routing strategy'.apply_attributeStatic()/];
  
    	/**
     	* Le mode de fonctionnement pour les ressources (DEBUG, etc..).
     	*/
    	private static ['operating mode'.apply_classEnum()/] ['operating mode'.apply_attributeStatic()/];
  
    	/**
     	* L'URL de base pour le serveur du fournisseur de ressources (http(s)://xxx.xxx.xxx/).
     	*/
    	private static String ['base url'.apply_attributeStatic()/];
  
  	/**
  	* L'URL complete pour un proxy (si besoin) (http(s)://xxx.xxx.xxx(:xxx)).
  	*/
  	private static String ['proxy url'.apply_attributeStatic()/];
  
  	/**
  	* L'utilisateur pour un proxy (si besoin)).
  	*/
  	private static String ['proxy user'.apply_attributeStatic()/];
  
  	/**
  	* Le mot de passe pour un proxy (si besoin)).
  	*/
  	private static String ['proxy passwd'.apply_attributeStatic()/];
  
  	/*
  	* Nombre maximum de clients http jersey dans le pool.
  	*/
    	private static int ['max pool clients'.apply_attributeStatic()/];
  
  	/*
  	* Utilisation de SSL (OUI / NON).
  	*/
    	private static boolean ['socket secured'.apply_attributeStatic()/];
  
  	/**
  	* Timeout pour la récupération des informations à partir du service.
  	*/
  	private static int ['read timeout'.apply_attributeStatic()/];
  
  	/**
  	* Timout pour la connexion au service.
  	*/
  	private static int ['connect timeout'.apply_attributeStatic()/];
  
    	/**
     	* Information spécifique pour la PES (DR).
     	*/
    	private static String ['pes application name'.apply_attributeStatic()/];
  
    	/**
     	* Information spécifique pour la PES (DR).
     	*/
    	private static String ['pes header secu'.apply_attributeStatic()/];
  
    	/**
     	* Information spécifique pour la PES (DR).
     	*/
    	private static String ['pes header mention'.apply_attributeStatic()/];
  
    	/**
     	* Information spécifique pour la PES (DR).
     	*/
    	private static String ['pes header constraint'.apply_attributeStatic()/];
  
  	/**
  	* Affichage console en majuscule des attributs dans le cadre du debogage. 
  	*/
  	private static boolean ['debug display attr upper'.apply_attributeStatic()/];
  
  	/**
  	* Affichage console des en-têtes dans le cadre du debogage.
  	*/
  	private static boolean ['debug display headers'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes application name key'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes header secu key'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes header mention key'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes header constraint key'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes header dlpp key'.apply_attributeStatic()/];
  
  	/**
  	* Clé en-tête pour information spécifique PES (DR).
  	*/
  	private static String ['pes header token key'.apply_attributeStatic()/];
  	
    	/**
     	* Chargement de la configuration pour l'application (option 1).
     	*
     	* @param ['config file path'.apply_parameterMethodClassicIn()/] :
     	* 				Le chemin complet du fichier de configuration.
     	*/
    	public static void ['configuration'.apply_methodGet()/](final URI ['config file path'.apply_parameterMethodClassicIn()/]) {
  
      	['load configuration'.apply_methodDefault()/](['config file path'.apply_parameterMethodClassicIn()/].getPath());
    	}
  
  
    	/**
     	* Chargement de la configuration pour l'application (option 2).
     	*
     	* @param ['application name'.apply_parameterMethodClassicIn()/] :
     	* 				Le nom de la variable système pour récupérer le
     	*               chemin du répertoire de stockage pour le(s) fichier(s) de configuration.
     	*/
    	public static void ['configuration'.apply_methodGet()/](final String ['application name'.apply_parameterMethodClassicIn()/]) {
  
      	final String ['config file path'.apply_variableFinal()/] = System.getenv(['application name'.apply_parameterMethodClassicIn()/].toUpperCase()
          	+ ['conf _filter _props _file'.apply_attributeFinalStatic()/]) + File.separator + "[any.getApplicationName()/]Application.properties";
  
      	['load configuration'.apply_methodDefault()/](['config file path'.apply_variableFinal()/]);
    	}
  
    	/**
     	* Récupération du mode de routage pour l'ensemble des ressources.
    	*
     	* @return Le mode de routage pour les ressources.
     	*/
    	public static ['routing strategy'.apply_classEnum()/] ['routing strategy'.apply_methodGet()/]() {
  
      	return ['routing strategy'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage de la stratégie de routage pour l'ensemble des ressources.
     	*
     	* @param ['routing strategy'.apply_parameterMethodClassicIn()/] :
     	* 				La stratégie de routage pour le filtre de l'application.
     	*/
    	public static void ['routing strategy'.apply_methodSet()/](final ['routing strategy'.apply_classEnum()/] ['routing strategy'.apply_parameterMethodClassicIn()/]) {
  
     		[any.buildRSFrontConfigClassName()/].['routing strategy'.apply_attributeStatic()/] = ['routing strategy'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération du mode de fonctionnement pour l'ensemble des ressources.
     	*
     	* @return Le mode de fonctionnement pour les ressources.
     	*/
    	public static ['operating mode'.apply_classEnum()/] ['operating mode'.apply_methodGet()/]() {
  
      	return ['operating mode'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage du mode de fonctionnement pour l'ensemble des ressources.
     	*
     	* @param ['operating mode'.apply_parameterMethodClassicIn()/] :
     	* 				Le mode de fonctionnement pour les ressources.
     	*/
    	public static void ['operating mode'.apply_methodSet()/](final ['operating mode'.apply_classEnum()/] ['operating mode'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['operating mode'.apply_attributeStatic()/] = ['operating mode'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération de l'URL de base pour le serveur du fournisseur de ressources.
     	*
     	* @return L'URL de base pour le serveur du fournisseur de ressources.
     	* @throws [any.buildRSFrontExceptionClassName()/] : L'URL de base ne peut pas être nulle.
     	*/
    	public static String ['base url'.apply_methodGet()/]() {
  
      	if (null == ['base url'.apply_attributeStatic()/]) {
        		throw new [any.buildRSFrontExceptionClassName()/](Status.INTERNAL_SERVER_ERROR.getStatusCode(),
            		"Aucune URL trouvée pour le serveur hébergeant les services REST !");
  		}
  
      	return ['base url'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage de l'URL pour le serveur hébergeant les ressources.
     	*
     	* @param ['base url'.apply_parameterMethodClassicIn()/] :
     	* 					l'URL pour le serveur hébergeant les ressources.
     	*/
    	public static void ['base url'.apply_methodSet()/](final String ['base url'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['base url'.apply_attributeStatic()/] = ['base url'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération de l'URL du proxy (si besoin).
     	*
     	* @return L'URL du proxy avant appel du serveur du fournisseur de ressources.
     	*/
    	public static String ['proxy url'.apply_methodGet()/]() {
  
      	return ['proxy url'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage de l'URL du proxy (si besoin).
     	*
     	* @param ['proxy url'.apply_parameterMethodClassicIn()/] :
     	* 					L'URL du proxy avant appel du serveur hébergeant les ressources.
     	*/
    	public static void ['proxy url'.apply_methodSet()/](final String ['proxy url'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['proxy url'.apply_attributeStatic()/] = ['proxy url'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération de l'utilisateur du proxy (si besoin).
     	*
     	* @return L'utilisateur pour le proxy.
     	*/
    	public static String ['proxy user'.apply_methodGet()/]() {
  
      	return ['proxy user'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage de l'utilisateur pour le proxy (si besoin).
     	*
     	* @param ['proxy user'.apply_parameterMethodClassicIn()/] :
     	* 					L'utilisateur pour le proxy.
     	*/
    	public static void ['proxy user'.apply_methodSet()/](final String ['proxy user'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['proxy user'.apply_attributeStatic()/] = ['proxy user'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération du mot de passe pour le proxy (si besoin).
     	*
     	* @return Le mot de passe pour le proxy.
     	*/
    	public static String ['proxy passwd'.apply_methodGet()/]() {
  
      	return ['proxy passwd'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramétrage du mot de passe pour le proxy (si besoin).
     	*
     	* @param ['proxy passwd'.apply_parameterMethodClassicIn()/] :
     	* 				 Le mot de passe pour le proxy.
     	*/
    	public static void ['proxy passwd'.apply_methodSet()/](final String ['proxy passwd'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['proxy passwd'.apply_attributeStatic()/] = ['proxy passwd'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Vérifie si l'application est située derrière la PES.
     	*
     	* @return True si le filtre doit être derrière la PES.
     	*/
    	public static boolean ['is pes headers required'.apply_methodDefault()/]() {
  
       	return ['routing strategy'.apply_attributeStatic()/] ==  ['routing strategy'.apply_classEnum()/].['pem _gateway'.apply_attributeEnum()/]
                || ['routing strategy'.apply_attributeStatic()/] == ['routing strategy'.apply_classEnum()/].['papi _gateway'.apply_attributeEnum()/];
    	}
  
    	/**
     	* Récupération d'un paramètre en-tête pour la PES (DR).
     	*
     	* @return Le paramètre.
     	*/
    	public static String ['pes application name'.apply_methodGet()/]() {
  
      	return ['pes application name'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage pour la PES.
  	*
     	* @param ['pes application name'.apply_parameterMethodClassicIn()/] : 
  	* 				Le paramètre.
     	*/
    	public static void ['pes application name'.apply_methodSet()/](final String ['pes application name'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes application name'.apply_attributeStatic()/] = ['pes application name'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'un paramètre en-tête pour la PES (DR).
     	*
     	* @return Le paramètre.
     	*/
    	public static String ['pes header secu'.apply_methodGet()/]() {
  
      	return ['pes header secu'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage pour la PES (DR)
  	*
     	* @param ['pes header secu'.apply_parameterMethodClassicIn()/] :
  	* 				Le paramètre.
     	*/
    	public static void ['pes header secu'.apply_methodSet()/](final String ['pes header secu'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header secu'.apply_attributeStatic()/] = ['pes header secu'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'un paramètre en-tête pour la PES (DR).
     	*
     	* @return Le paramètre.
     	*/
    	public static String ['pes header mention'.apply_methodGet()/]() {
  
      	return ['pes header mention'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage pour la PES (DR).
  	*
    	* @param ['pes header mention'.apply_parameterMethodClassicIn()/] : 
  	* 				Le paramètre.
     	*/
    	public static void ['pes header mention'.apply_methodSet()/](final String ['pes header mention'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header mention'.apply_attributeStatic()/] = ['pes header mention'.apply_parameterMethodClassicIn()/];
    	} 
  
    	/**
     	* Récupération d'un paramètre en-tête pour la PES (DR).
     	*
     	* @return Le paramètre.
     	*/
    	public static String ['pes header constraint'.apply_methodGet()/]() {
  
      	return ['pes header constraint'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage pour la PES (DR).
  	*
     	* @param ['pes header constraint'.apply_parameterMethodClassicIn()/] : 
  	* 				Le paramètre.
     	*/
    	public static void ['pes header constraint'.apply_methodSet()/](final String ['pes header constraint'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header constraint'.apply_attributeStatic()/] = ['pes header constraint'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header constraint key'.apply_methodGet()/]() {
  
      	return ['pes header constraint key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header constraint key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header constraint key'.apply_methodSet()/](final String ['pes header constraint key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header constraint key'.apply_attributeStatic()/] = ['pes header constraint key'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header app key'.apply_methodGet()/]() {
  
      	return ['pes application name key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header app key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header app key'.apply_methodSet()/](final String ['pes application name key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes application name key'.apply_attributeStatic()/] = ['pes application name key'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header secu key'.apply_methodGet()/]() {
  
      	return ['pes header secu key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header secu key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header secu key'.apply_methodSet()/](final String ['pes header secu key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header secu key'.apply_attributeStatic()/] = ['pes header secu key'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header mention key'.apply_methodGet()/]() {
  
      	return ['pes header mention key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header mention key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header mention key'.apply_methodSet()/](final String ['pes header mention key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header mention key'.apply_attributeStatic()/] = ['pes header mention key'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header dlpp key'.apply_methodGet()/]() {
  
      	return ['pes header dlpp key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header dlpp key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header dlpp key'.apply_methodSet()/](final String ['pes header dlpp key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header dlpp key'.apply_attributeStatic()/] = ['pes header dlpp key'.apply_parameterMethodClassicIn()/];
    	}
  
    	/**
     	* Récupération d'une clé pour paramètre en-tête pour la PES (DR).
     	*
     	* @return La clé.
     	*/
    	public static String ['pes header token key'.apply_methodGet()/]() {
  
      	return ['pes header token key'.apply_attributeStatic()/];
    	}
  
    	/**
     	* Paramètrage de la clé pour la PES (DR).
  	*
     	* @param ['pes header token key'.apply_parameterMethodClassicIn()/] : 
  	* 				La clé.
     	*/
    	public static void ['pes header token key'.apply_methodSet()/](final String ['pes header token key'.apply_parameterMethodClassicIn()/]) {
  
      	[any.buildRSFrontConfigClassName()/].['pes header token key'.apply_attributeStatic()/] = ['pes header token key'.apply_parameterMethodClassicIn()/];
    	}
  
  	/**
  	* Récupération pour la sécurisation du transfert des données (SSL).
  	*
  	* @return true si l'API fonctionne sous SSL.
  	*/
  	public static boolean ['is socket secured'.apply_methodDefault()/]() {
  
  		return ['socket secured'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage pour la sécurisation du transfert des données (SSL).
  	*
  	* @param ['socket secured'.apply_parameterMethodClassicIn()/] : 
  	* 					true ou false selon que l'API fonctionne ou non en mode SSL.
  	*/
  	public static void ['socket secured'.apply_methodSet()/](final boolean ['socket secured'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['socket secured'.apply_attributeStatic()/] = ['socket secured'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération du timout de connexion pour le client.
  	*
  	* @return la valeur en millisecondes du timeout de connexion.
  	*/
  	public static int ['connect timeout'.apply_methodGet()/]() {
  	
  		if(0 == ['connect timeout'.apply_attributeStatic()/]) {
  			return 500; //TODO passer en constante.
  		}
  
  		return ['connect timeout'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage du timout de connexion pour le client.
  	*
  	* @param ['connect timeout'.apply_parameterMethodClassicIn()/] : 
  	* 					La valeur en millisecondes pour le timeout de connexion.
  	*/
  	public static void ['connect timeout'.apply_methodSet()/](final int ['connect timeout'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['connect timeout'.apply_attributeStatic()/] = ['connect timeout'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération du timeout en milliseconde pour la lecture des données pour le client.
  	*
  	* @return le timeout en millisecondes pour la lecture des données.
  	*/
  	public static int ['read timeout'.apply_methodGet()/]() {
  
  		if(0 == ['read timeout'.apply_attributeStatic()/]) {
  			return 2000; //TODO passer en constante.
  		}
  
  		return ['read timeout'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage du timeout en milliseconde pour la lecture des données pour le client.
  	*
  	* @param ['read timeout'.apply_parameterMethodClassicIn()/] : 
  	* 					La valeur en millisecondes pour le timeout de lecture des données.
  	*/
  	public static void ['read timeout'.apply_methodSet()/](final int ['read timeout'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['read timeout'.apply_attributeStatic()/] = ['read timeout'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération du nombre maximum de clients http dans le pool.
  	*
  	* @return le nombre maximum de clients http authorisés.
  	*/
  	public static int ['max pool clients'.apply_methodGet()/]() {
  
  		return ['max pool clients'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage du nombre maximum de clients http dans le pool.
  	*
  	* @param ['max pool clients'.apply_parameterMethodClassicIn()/] : 
  	* 					Le nombre maximum de clients http authorisés..
  	*/
  	public static void ['max pool clients'.apply_methodSet()/](final int ['max pool clients'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['max pool clients'.apply_attributeStatic()/] = ['max pool clients'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération de l'indicateur d'affichage Majuscule pourle debogage.
  	*
  	* @return true si le développeur demande l'affichage des attributs en majuscule.
  	*/
  	public static boolean ['is debug display attr upper'.apply_methodDefault()/]() {
  
  		return ['debug display attr upper'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage de  l'indicateur d'affichage Majuscule pourle debogage.
  	*
  	* @param ['debug display attr upper'.apply_parameterMethodClassicIn()/] : 
  	* 					true ou false selon affichage ou non des données en majuscule.
  	*/
  	public static void ['debug display attr upper'.apply_methodSet()/](final boolean ['debug display attr upper'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['debug display attr upper'.apply_attributeStatic()/] = ['debug display attr upper'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Récupération de l'indicateur d'affichage des en-têtes pour le débogage.
  	*
  	* @return l'indicateur d'affichage des en-têtes pour le débogage.
  	*/
  	public static boolean ['is debug display headers'.apply_methodDefault()/]() {
  
  		return ['debug display headers'.apply_attributeStatic()/];
  	}
  
  	/**
  	* Paramétrage de l'indicateur d'affichage des en-têtes pour le débogage.
  	*
  	* @param ['debug display headers'.apply_parameterMethodClassicIn()/] : 
  	* 					true ou false selon affichage ou non des en-têtes.
  	*/
  	public static void ['debug display headers'.apply_methodSet()/](final boolean ['debug display headers'.apply_parameterMethodClassicIn()/]){
  
  		[any.buildRSFrontConfigClassName()/].['debug display headers'.apply_attributeStatic()/] = ['debug display headers'.apply_parameterMethodClassicIn()/];
  	}
  
  	/**
  	* Indique si le mode opératoire est 'DEBUG'.
  	*
  	* @return TRUE si le mode opératoire est 'DEBUG'.
  	*/
  	public static boolean ['is debug mode'.apply_methodDefault()/](){
  
  		return ['operating mode'.apply_attributeStatic()/]  == ['operating mode'.apply_classEnum()/].['debug'.apply_attributeEnum()/];
  	}
  
  	/**
  	* Indique si le mode opératoire est 'TEST'.
  	*
  	* @return TRUE si le mode opératoire est 'TEST'.
  	*/
  	public static boolean ['is test mode'.apply_methodDefault()/](){
  
  		return ['operating mode'.apply_attributeStatic()/]  == ['operating mode'.apply_classEnum()/].['test'.apply_attributeEnum()/];
  	}
  
  	/**
  	* Indique si le mode opératoire est 'INTEG'.
  	*
  	* @return TRUE si le mode opératoire est 'INTEG'.
  	*/
  	public static boolean ['is integ mode'.apply_methodDefault()/](){
  
  		return ['operating mode'.apply_attributeStatic()/]  == ['operating mode'.apply_classEnum()/].['integ'.apply_attributeEnum()/];
  	}
  
  	/**
  	* Indique si le mode opératoire est 'PROD'.
  	*
  	* @return TRUE si le mode opératoire est 'PROD'.
  	*/
  	public static boolean ['is prod mode'.apply_methodDefault()/](){
  
  		return ['operating mode'.apply_attributeStatic()/]  == ['operating mode'.apply_classEnum()/].['prod'.apply_attributeEnum()/];
  	}
  
    	/**
     	* Chargement de la configuration pour l'application.
     	*
     	* @param ['properties file name'.apply_parameterMethodClassicIn()/] :
     	* 				Le chemin complet du fichier de configuration.
     	*/
    	private static void ['load configuration'.apply_methodDefault()/](final String ['properties file name'.apply_parameterMethodClassicIn()/]) {
  
  		// Comme la classe est 'static', stoppe le chargement lors de multiples appels.
      	if (['loaded'.apply_attributeStatic()/]) {
        		return;
  		}
  
  		// Affichage du chemin pour le fichier de configuration.
  		['config log'.apply_attributeFinalStatic()/].info("Chargement de la configuration : " 
  				+ ['properties file name'.apply_parameterMethodClassicIn()/]);
  
      	final Properties ['props'.apply_variableFinal()/] = new Properties();
  
      	try (InputStream ['input stream'.apply_variableFinal()/] = new FileInputStream(['properties file name'.apply_parameterMethodClassicIn()/])){
        		['props'.apply_variableFinal()/].load(['input stream'.apply_variableFinal()/]);
  
        		['pes application name'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _pes _header _app'.apply_attributeFinalStatic()/]));
  
        		['pes header constraint'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _pes _header _constraint'.apply_attributeFinalStatic()/]));
  
        		['pes header mention'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _pes _header _mention'.apply_attributeFinalStatic()/]));
  
        		['pes header secu'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _pes _header _secu'.apply_attributeFinalStatic()/]));
  
        		['pes header secu key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _secu'.apply_attributeFinalStatic()/]));
  
        		['pes header app key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _app _name'.apply_attributeFinalStatic()/]));
  
        		['pes header mention key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _mention'.apply_attributeFinalStatic()/]));
  
        		['pes header constraint key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _constraint'.apply_attributeFinalStatic()/]));
  
        		['pes header dlpp key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _dlpp'.apply_attributeFinalStatic()/]));
  
        		['pes header token key'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['auth _header _pes _token'.apply_attributeFinalStatic()/]));
  
  	  		['base url'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _base _url'.apply_attributeFinalStatic()/]));
  
  	  		['proxy url'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _proxy _url'.apply_attributeFinalStatic()/]));
  
  	  		['proxy user'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _proxy _user'.apply_attributeFinalStatic()/]));
  
  	  		['proxy passwd'.apply_methodSet()/](['props'.apply_variableFinal()/].getProperty(
  				['conf _filter _proxy _passwd'.apply_attributeFinalStatic()/]));
  
  			['max pool clients'.apply_methodSet()/](Integer.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _client _pool _max'.apply_attributeFinalStatic()/])));
  
  			['connect timeout'.apply_methodSet()/](Integer.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _client _connect _timeout'.apply_attributeFinalStatic()/])));
  
  			['read timeout'.apply_methodSet()/](Integer.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _client _read _timeout'.apply_attributeFinalStatic()/])));
  			
  			['socket secured'.apply_methodSet()/](Boolean.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _filter _socket _secured'.apply_attributeFinalStatic()/])));
  
  			['debug display attr upper'.apply_methodSet()/](Boolean.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _debug _display _attr _upper'.apply_attributeFinalStatic()/])));
  
  			['debug display headers'.apply_methodSet()/](Boolean.valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _debug _display _headers'.apply_attributeFinalStatic()/])));
  
        		['operating mode'.apply_methodSet()/](['operating mode'.apply_classEnum()/].valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _filter _operating _mode'.apply_attributeFinalStatic()/])));
  
        		['routing strategy'.apply_methodSet()/](['routing strategy'.apply_classEnum()/].valueOf(
  				['props'.apply_variableFinal()/].getProperty(['conf _filter _routing _strategy'.apply_attributeFinalStatic()/])));
  
  			// Chargement de la configuration des jetons (si nécessaire).
  			[any.buildRSFrontTokensConfigClassName()/].['load configuration'.apply_methodDefault()/](['props'.apply_variableFinal()/]);
  
        		['loaded'.apply_attributeStatic()/] = Boolean.TRUE;
  
      	} catch (final FileNotFoundException ['e'.apply_parameterMethodClassicIn()/]) {
  
        		throw new [any.buildRSFrontExceptionClassName()/]( Status.INTERNAL_SERVER_ERROR.getStatusCode(),
            		"Impossible de trouver le fichier de configuration de l'application pour les services REST : "
  				+ ['properties file name'.apply_parameterMethodClassicIn()/]);
  
      	} catch (final Exception ['e'.apply_parameterMethodClassicIn()/]) {
  
        		throw new [any.buildRSFrontExceptionClassName()/]( Status.INTERNAL_SERVER_ERROR.getStatusCode(),
            		"Impossible de charger la configuration de l'application pour les services REST : " 
  				+ ['e'.apply_parameterMethodClassicIn()/].getMessage());
      	}
    	}
  
    	/**
     	* Enumération des différents modes de routage pour les clients (ressources).
     	*
     	* - PEM = Platforme d'Echange et de Médiation (API Management entre 2 applications sur Intradef).
     	* - PAPI => PEM entre Intradef et Internet (2 PEM qui discutent entre elles).
     	*
     	* - API_GATEWAY : Le client est positionné derrière une passerelle (autre que PES).
     	* - PEM_GATEWAY : Le client est positionné derrière la passerelle spécifique du PES.
     	* - PAPI_GATEWAY : Le client est positionné derrière les passerelles spécifiques du PES.
     	* - STANDALONE : Le client est en accès libre sur Internet.
     	*/
    	protected enum ['routing strategy'.apply_classEnum()/] {
  
      	['api_gateway'.apply_attributeEnum()/], ['pem_gateway'.apply_attributeEnum()/], ['papi_gateway'.apply_attributeEnum()/], ['standalone'.apply_attributeEnum()/]
    	}
  
    	/**
     	* Enumération des différents modes de fonctionnement  pour les clients.
     	*/
    	protected enum ['operating mode'.apply_classEnum()/] {
  
      	['debug'.apply_attributeEnum()/], ['test'.apply_attributeEnum()/], ['integ'.apply_attributeEnum()/], ['prod'.apply_attributeEnum()/];
    	}
  }[/template]

[comment : **************************************************************/]
[comment : Create the abstract main super-class for the front resources. /]
[comment : **************************************************************/]
[template public rsFrontResourceAbstract(any : ecore::EObject)]
  [any.licence()/]
  package [any.buildPackageRsFront()/];
  [protected ('for imports') startTagPrefix('// ') endTagPrefix('// ')]
    
    import jakarta.ws.rs.client.WebTarget;
    import jakarta.ws.rs.core.Response;
    
  [/protected]
  
  
  /**
   * Classe abstraite d'assistance pour les ressources client.
   *
   * @author [any.getAuthorName()/].
   */
  public abstract class [any.buildRSFrontResourcesAbstractClassName()/]
  {
    /**
     * Contient le fragment principal de l'URI (URL serveur + URI de ressource).
     * On s'arrête donc au niveau de la méthode qui contient son annotation @PATH.
     */
    private final String ['base uri'.apply_attributeFinal()/];
  
    /**
     * Chargement de la configuration.
     */
    static {
  
      ['static configuration'.displayClearUserCodeId()/]
      [protected (any.getUserCodeId('static configuration')) startTagPrefix('//') endTagPrefix('//')]
        
            // Chargement de la configuration pour l'application.
            [any.buildRSFrontConfigClassName()/].['configuration'.apply_methodGet()/]("[any.getApplicationName().toUpper()/]");
        
            // Paramétrage du mode opératoire (DEBUG / TEST /  etc...) pour l'application.
            [any.buildRSFrontConfigClassName()/].['operating mode'.apply_methodSet()/](
        			[any.buildRSFrontConfigClassName()/].['operating mode'.apply_classEnum()/].['debug'.apply_attributeEnum()/]);
        
      [/protected]
  
    }
  
    /**
     * Constructeur.
     *
     * @param ['base uri'.apply_parameterMethodClassicIn()/] :
     *				Le fragment de base pour permettre la construction de l'URI de la ressource.
     */
    protected [any.buildRSFrontResourcesAbstractClassName()/](final String ['base uri'.apply_parameterMethodClassicIn()/]) {
  
      [any.getAffectationPrefix()/]['base uri'.apply_attributeFinal()/] = ['build target'.apply_methodDefault()/](['base uri'.apply_parameterMethodClassicIn()/]);
    }
  
    /**
     * Obtient le client REST et la "WebTarget" pour la ressource.
     *
     * @return La "WebTarget" de la ressource spécifique.
     */
    protected WebTarget ['target'.apply_methodDefault()/]() {
  
      ['for target'.displayClearUserCodeId()/]
      [protected (any.getUserCodeId('for target')) startTagPrefix('//') endTagPrefix('//')]
        
            return [any.buildRSClientFactoryClassName()/].['client'.apply_methodGet()/]().target(['base uri'.apply_attributeFinal()/]);
        
      [/protected]
  
    }
  
    /**
     * Ferme la réponse avant de lire les en-têtes.
     * Cette méthode est spécifique pour les opérations de type "HEAD",
     * elle permet de conserver le pattern "fluent" de l'API.
     *
     * @param ['response'.apply_parameterMethodClassicIn()/] :
     * 					L'objet de réponse avec le code d'état.
     * @return La réponse (fermée) mais toujours fonctionnelle pour lire les en-têtes.
     */
    protected Response ['close'.apply_methodDefault()/](final Response ['response'.apply_parameterMethodClassicIn()/]) {
  
      ['response'.apply_parameterMethodClassicIn()/].close();
      return ['response'.apply_parameterMethodClassicIn()/];
    }
  
    /**
     * Création de l'URI de base pour la ressource.
     * (Jusqu'à l'URI de la méthode : ex : https://www.server.com/ws/resource/..)
     *
     * @param ['target'.apply_parameterMethodClassicIn()/] :
     * 				Un fragment d'URI pour la ressource spécifique.
     * @return l'URI complete (base) pour la ressource.
     */
    private String ['build target'.apply_methodDefault()/](final String ['target'.apply_parameterMethodClassicIn()/]){
  
      ['for build target base uri'.displayClearUserCodeId()/]
      [protected (any.getUserCodeId('for build target base uri')) startTagPrefix('//') endTagPrefix('//')]
        
            StringBuffer ['sbuff base uri'.apply_variableDefault()/] = new StringBuffer();
            ['sbuff base uri'.apply_variableDefault()/].append([any.buildRSFrontConfigClassName()/].['base url'.apply_methodGet()/]());
        
            if(['sbuff base uri'.apply_variableDefault()/].length() == 0) {
              ['sbuff base uri'.apply_variableDefault()/].append("");
            }
        
            ['sbuff base uri'.apply_variableDefault()/].append(['target'.apply_parameterMethodClassicIn()/]);
            String ['base uri'.apply_variableDefault()/] = ['sbuff base uri'.apply_variableDefault()/].toString();
            return ['base uri'.apply_variableDefault()/].replaceAll("(?<!(http:|https:))//", "/");
        
      [/protected]
  
    }
  }[/template]
